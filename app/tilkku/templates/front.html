{% extends "base.html" %}
{% block content %}
{% csrf_token %}
<script>
const csrf_token = document.querySelector('[name="csrfmiddlewaretoken"]').value;

var location_query = {};
if(location.search) {
    location.search.split('?')[1].split('&').forEach(function(item) {
        var key = item.split('=')[0];
        var value = item.split('=')[1];
        location_query[key] = value;
    });
}

var default_settings = {
    menu: "visible",
    tool: "chat",
    clock: true,
    map: {
        center: {
            lat: 61.205,
            lng: 25.130
        },
        zoom: 15,
        server: 0,
        layers: [],
        scale: 1,
    }
}

function refresh_settings() {
    localStorage.setItem('settings', JSON.stringify(settings));
}

function compare_objects(obj1, obj2) {
    for(const [key, value] of Object.entries(obj1)) {
        if(Array.isArray(value)) {
            if(typeof obj2[key] == "undefined") {
                obj2[key] = value;
            }
        } else if(typeof value == "object") {
            obj2[key] = compare_objects(obj1[key], obj2[key]);
        } else {
            if(typeof obj2[key] == "undefined") {
                obj2[key] = value;
            }
        }
    }
    return obj2;
}

function compare_settings(settings) {
    settings = compare_objects(default_settings, settings);
    refresh_settings();
}

if(localStorage.getItem('settings') == null) {
    settings = default_settings;
    refresh_settings();
} else {
    settings = JSON.parse(localStorage.getItem('settings'));
    compare_settings(settings);
}

var map = null;

</script>
<style>
.leaflet-tooltip {
    border: none;
    background: none;
    box-shadow: none;
    font-weight: bold;
    font-size: 1.4em;
    -webkit-text-stroke: 1px black;
}

.grid-line {
    stroke: #0000001a;
    stroke-width: 1;
    fill-opacity: 0;
}
</style>

<div id="map" style="width: 100%; height: 100%; position: fixed; top: 0; left: 0;"></div>
<div class="columns" style="height: 100%; margin: 0px;">
    <div class="column" style="width: auto; min-width: 66%;">
        <div style="width: 150px; float: left; margin-left: 42px;">
            {% include 'clock.html' %}
        </div>
        <div style="width: 32px; float: right;">
            {% include 'toolbox.html' %}
        </div>
    </div>
    <div id="front-tools" class="column is-third" style="z-index: 2;">
        <div class="box p-0" style="height: calc(100% - 10px);">
            {% include 'tools.html' %}
        </div>
    </div>
</div>

<div id="map-coordinates" class="box is-size-7 p-1 has-text-centered is-hidden" style="position: fixed; left: 5px; bottom: 5px; width: 40px; opacity: 0.7;">
    <p></p>
</div>

{% include 'modals.html' %}

<script>

var home = [61.205, 25.130];
var home_zoom = 15;
map = L.map('map').setView(settings.map.center, settings.map.zoom);

const forwarder = L.eventForwarder({
    map: map,
    events: {
        click: true,
        mousemove: false,
    },
}).enable();

map_servers = {{ map_servers | safe }};

map_servers.forEach(function(server) {
    server.layer = L.tileLayer(server.url, {
        attribution: server.attribution,
    });
});

var map_background = map_servers[settings.map.server].layer.addTo(map);

function map_set_bg() {
    map_background.remove();
    map_background = map_servers[settings.map.server].layer.addTo(map);
}

var grid_size = [-52, 112.5];
var grid_transfer = 100000;
var grid_start = [61.21340, 25.10560];
var grid_end = [];
var grid_cols = ["01","02","03","04","05","06","07","08","09","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30"];
var grid_rows = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];
var map_grid = {
    x: grid_start[0],
    y: grid_start[1],
    min_x: grid_start[0],
    min_y: grid_start[1],
    max_x: grid_start[0],
    max_y: grid_start[1],
    inv_x: false,
    inv_y: false,
    layer:null,
};

function map_set_grid() {
    console.log(settings);
    if(!settings.map.grid) {
        if(map_grid.layer != null) {
            map_grid.layer.remove();
            map_grid.layer = null;
        }
        return;
    }
    var x = map_grid.x;
    var y = map_grid.y;
    var row = 0;
    var col = 0;
    map_grid.layer = L.layerGroup().addTo(map);
    for(var row = 0; row <= grid_rows.length; row++) {
        var rowLine = L.polyline([
            [x + row * (grid_size[0]/grid_transfer), y],
            [x + row * (grid_size[0]/grid_transfer), y + grid_cols.length * (grid_size[1]/grid_transfer)],
        ], {
            className: 'grid-line',
        }).addTo(map_grid.layer);
    }
    for (var col = 0; col <= grid_cols.length; col++) {
        var colLine = L.polyline([
            [x, y + col * (grid_size[1]/grid_transfer)],
            [x + grid_rows.length * (grid_size[0]/grid_transfer), y + col * (grid_size[1]/grid_transfer)],
        ], {
            className: 'grid-line',
        }).addTo(map_grid.layer);
    }

    grid_end = [x + grid_rows.length * (grid_size[0]/grid_transfer), y + grid_cols.length * (grid_size[1]/grid_transfer)];

    if(grid_end[0] < grid_start[0]) {
        map_grid.min_x = grid_end[0];
        map_grid.max_x = grid_start[0];
        map_grid.inv_x = true;
    } else {
        map_grid.min_x = grid_start[0];
        map_grid.max_x = grid_end[0];
    }

    if(grid_end[1] < grid_start[1]) {
        map_grid.min_y = grid_end[1];
        map_grid.max_y = grid_start[1];
        map_grid.inv_y = true;
    } else {
        map_grid.min_y = grid_start[1];
        map_grid.max_y = grid_end[1];
    }

    var gridbox = L.rectangle([[x, y], [grid_end[0], grid_end[1]]], {
        weight: 1,
        fillOpacity: 0,
        stroke: false,
        cursor: 'none',
    }).addTo(map_grid.layer);

    var tooltip_style = {
        permanent: true,
        direction: "center",
    }

    for(var i = 0; i < grid_rows.length; i++) {
        var rowHeader = L.marker([x + (grid_size[0]/grid_transfer)/2 + (i+1) * (grid_size[0]/grid_transfer), y - (grid_size[1]/grid_transfer)/2], {
            opacity: 0,
        });
        rowHeader.bindTooltip("<div class='grid-header'>" + grid_rows[i] + "</div>", tooltip_style);
        map_grid.layer.addLayer(rowHeader);
        console.log(rowHeader.getTooltip());
    }

    gridbox.on("mousemove", function(e) {
        map_show_coords(e.latlng);
    });
    gridbox.on("mouseout", function(e) {
        $("#map-coordinates").addClass("is-hidden");
    });
}

map_scale = L.control.scale({
    imperial: false,
    metric: true,
    position: 'bottomleft'
});

function map_set_scale() {
    if(settings.map.scale == 1) {
        map_scale.addTo(map);
    } else {
        map_scale.remove();
    }
}

map_set_scale();

map.on("moveend", function() {
    settings.map.center = map.getCenter();
    settings.map.zoom = map.getZoom();
    refresh_settings();
});

var lastZoom;

function map_set_names() {
    var zoom = map.getZoom();
    map_layers.forEach(function(layer) {

        if(layer.active) {
            layer.layer.eachLayer(function(layer2) {
                var tooltip = layer2.getTooltip();
                if(tooltip) {
                    this.map.closeTooltip(tooltip);
                }
                if(tooltip && zoom >= layer.style.min_zoom && zoom <= layer.style.max_zoom && settings.map.names) {
                    this.map.addLayer(tooltip);
                }
            });

        }
    });
}

var map_layers = {{ layers | safe }};

map_layers.forEach(function(layer) {
    layer.areas.forEach(function(area) {
        for(var i = 0; i < area.coordinates.length; i++) {
            area.coordinates[i] = [area.coordinates[i][1], area.coordinates[i][0]];
        }
    });
    layer.markers.forEach(function(marker) {
        marker.coordinates = [marker.coordinates[1], marker.coordinates[0]];
    });
});

function map_load_layers() {
    for(var i = 0; i < map_layers.length; i++) {
        var layer = map_layers[i];
        if(layer.layer) {
            layer.layer.remove();
        }

        var style = {
            color: layer.style.stroke,
            fillColor: layer.style.fill,
            opacity: layer.style.opacity + 0.2,
            fillOpacity: layer.style.opacity,
            'stroke-width': layer.style.stroke_width,
        }

        var tooltip_style = {
            opacity: layer.style.opacity + 0.2,
            permanent: true,
            direction: "center",
        }

        var marker_style = {
            opacity: 0,
        }

        layer.active = false;

        if(settings.map.layers.includes(i)) {
            layer.layer = L.featureGroup();
            layer.active = true;

            layer.areas.forEach(function(area) {
                var polydata = style;
                polydata.id = area.id;
                area_layer = L.polygon(area.coordinates, polydata);
                area_layer.bindTooltip("<div style='color: " + layer.style.stroke + "; font-size: " + layer.style.font_size + "px'>" + area.name + "</div>", tooltip_style);
                area_layer.addTo(layer.layer);
                area_layer.on("click", function(e) {
                    e.originalEvent._stopped = true;
                    open_area(e.target.options.id);
                });

                area.active = true;
            });

            layer.markers.forEach(function(marker) {
                var marker_layer = L.marker(marker.coordinates, marker_style)
                marker_layer.bindTooltip("<div style='color: " + layer.style.stroke + "; font-size: " + layer.style.font_size + "px'>" + marker.name + "</div>", tooltip_style);
                marker_layer.addTo(layer.layer);
                marker_layer.on("click", function(e) {
                    open_marker(e.target.options.id);
                });

                marker.active = true;
            });

            layer.layer.addTo(map);
        } else {
            layer.active = false;
            layer.layer = L.featureGroup();

            layer.areas.forEach(function(area) {
                area.active = false;
            });

            layer.markers.forEach(function(marker) {
                marker.active = false;
            });
        }
    }
    map_set_grid();
    map_set_names();
}

function map_get_layer(id) {
    var correct_layer = null;
    map.eachLayer(function(layer) {
        if(layer.options.id == id) {
            correct_layer = layer;
            return;
        }
    });
    return correct_layer;
}

function map_set_layers() {
    map_load_layers();
}
map_set_layers();

map.on('zoomend', function() {
    map_set_names();
});

var opened_area = null;

function open_area(id) {
    map_layers.forEach(function(layer) {
        layer.areas.forEach(function(area) {
            if(area.id == id) {
                opened_area = area;
                return;
            }
        });
    });
    open_site_modal(opened_area.id, null);
}

var opened_marker = null;

function open_marker(id) {
    map_layers.forEach(function(layer) {
        layer.markers.forEach(function(marker) {
            if(marker.id == id) {
                opened_marker = marker;
                return;
            }
        });
    });
    open_site_modal(null, opened_marker.id);
}

function map_init() {
    map_set_bg();
    map_set_scale();
    map_set_layers();
}

function map_show_coords(latlng) {
    if(map_grid.min_x < latlng.lat && latlng.lat < map_grid.max_x && map_grid.min_y < latlng.lng && latlng.lng < map_grid.max_y) {
        var row = Math.floor((grid_end[0] - latlng.lat) / (grid_size[0]/grid_transfer));
        if(map_grid.inv_x) {
            row = grid_rows.length - row - 1;
        }
        var col = Math.floor((latlng.lng - grid_start[1]) / (grid_size[1]/grid_transfer));
        if(map_grid.inv_y) {
            col = grid_cols.length - col - 1;
        }
        var coords = grid_rows[row] + grid_cols[col];
        $("#map-coordinates p").text(coords);
        $("#map-coordinates").removeClass("is-hidden");
    }
}

</script>
{% include 'settings.html' %}
{% endblock %}